-- Custom types are used to define the type of a column in a table.
-- decimal: a floating point number
-- integer: an integer number
-- enum: a set of values, specified in redis
CREATE TABLE custom_type(
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    kind text NOT NULL CHECK (kind IN ('decimal', 'integer', 'enum', 'date', 'time')),
    name text NOT NULL,
    description text NOT NULL,
    rules text[] NOT NULL DEFAULT '{}',
    examples text[] NOT NULL DEFAULT '{}',
    not_examples text[] NOT NULL DEFAULT '{}',
    user_id uuid NOT NULL,
    values_key text GENERATED ALWAYS AS ( CASE WHEN kind = 'enum' THEN
        'br-values-' || id
    ELSE
        NULL
    END) STORED,
    min_value numeric NOT NULL DEFAULT '-Infinity',
    max_value numeric NOT NULL DEFAULT 'Infinity',
    log_scale boolean NOT NULL DEFAULT FALSE,
    public boolean NOT NULL DEFAULT FALSE,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (name, user_id)
);

ALTER TABLE custom_type ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Users can manage their own custom types" ON custom_type
    FOR ALL TO authenticated
        USING (auth.uid() = user_id);

CREATE POLICY "Anyone can read public custom types" ON custom_type
    FOR SELECT
        USING (public = TRUE);

-- Create a table to track dirty custom types per table
CREATE TABLE dirty_custom_type(
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type_id uuid NOT NULL REFERENCES custom_type(id) ON DELETE CASCADE,
    table_identification_id bigint NOT NULL REFERENCES table_identification(id) ON DELETE CASCADE,
    user_id uuid NOT NULL,
    marked_at timestamptz NOT NULL DEFAULT now(),
    UNIQUE (type_id, table_identification_id, user_id)
);

ALTER TABLE dirty_custom_type ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users manage their dirty custom types" ON dirty_custom_type
    FOR ALL TO authenticated
        USING (auth.uid() = user_id);

-- Function to find tables using a specific custom type ID
CREATE OR REPLACE FUNCTION find_tables_using_custom_type(type_id_param uuid)
    RETURNS TABLE(
        prefixed_id text
    )
    AS $$
BEGIN
    RETURN QUERY WITH identification_columns AS(
        SELECT
            ti.prefixed_id,
            jsonb_object_keys(ti.identifications::jsonb -> 'identifications') AS column_key
        FROM
            table_identification ti
)
    SELECT DISTINCT
        ic.prefixed_id
    FROM
        identification_columns ic
        JOIN table_identification ti ON ic.prefixed_id = ti.prefixed_id
    WHERE
        -- Check if the JSON at this path has the properties we're looking for
(ti.identifications::jsonb -> 'identifications' -> ic.column_key -> 'is_custom')::boolean = TRUE
        AND(ti.identifications::jsonb -> 'identifications' -> ic.column_key ->> 'id') = type_id_param::text;
END;
$$
LANGUAGE plpgsql;

